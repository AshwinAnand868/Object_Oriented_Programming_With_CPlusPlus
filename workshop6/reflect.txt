//Name - Ashwin Anand
//email - aanand24@myseneca.ca
//student id - 152042206
//date - 2022/03/12
//I have done all the coding by myself and only copied the code that my professor provided to complete my workshops and assignments.

													Reflection

In this workshop, I learned various things for example, working with vector container of the STL library which contains the pointers pointing to objects of derived classes of an Abstract base class named Resource. For the insertion of the elements in the vector object, I used push_back function and when I wanted to access the first or last element, I made use of the front and back member functions respectively. Along with working with the vector container, I also declared iterator of the given type (Resource*) in my implementation to get the position of an element to be removed in my remove member function of the Directory and then for removal I used erase member function by passing the iterator to the argument of this function so that the element that the user wants to remove can actually be removed from the container after deallocating memory for that element. Moreover, I got again an opportunity to work with the file formatting, extracting data from the file and store that data into specific variables based on the delimiters in the file. In addition to mentioning these things, there are other two things that was kind of more fundamental to the design. One of these is the constructor of the filesystem class in which I actually worked with the file reading as mentioned above.  In this constructor along with the file reading, there was one thing that at first seems confusing to me and that was related to the directory structure creation. Let me explain that with an example. For example, suppose if I got the directory structure like images/scene.jpg which is present in the root “/” directory. At first, for this structure, I created an images directory in my root directory and that was right, but after this when I created the file scene.jpg it also got created in the root directory. I was confused that l wanted it to get created in the images directory, however it is in root directory. Then after spending some time focusing on the problem, I got to know that operation for adding the file should be performed in the current directory and my current directory was initially initialized as root directory. So, whenever any file, in this case scene.jpg, needs to be added to current directory, my current directory should be changed to the directory I recently created like images and then that file should be added to that directory. Another thing that was used many times in the application was the find member function declared and defined in the Directory class. Implementing the logic for this function was kind of interesting because it involved the Recursive operation, if specified, for the directories. In this function, if the given resource name is not found in the current directory and if the recursive flag is on or provided, then this function will first check if the given resource is a directory and if it is, then it would call itself on that directory object and will try to find the resource in that directory. Now apart from my learnings, let me discuss the questions asked in the reflection.
 
Question – 1 Why do you need to deallocate the dynamically allocated memory in your vector of resources?
Answer – I need to dynamically deallocate the memory in the vector of resources because, although the vector can manage the memory for itself, the objects in this vector that are being pointed must be deallocated manually. This means while pushing any resource to the vector, that resource should be able to deallocate itself and this thing would only be possible if I coded the logic for deallocation for the respective directory or file object. 

Question – 2 To call specific functions for a Directory objects stored in a Resource*, what special C++ operation did you have to do and why?
Answer – To achieve the purpose asked, I needed to use the dynamic_cast operation. After getting that the type of the current resource is directory, I need to dynamically cast that object pointed by the resource to the directory so that I can perform the member functions of Directory class on that object. If I simply try to call any member function on the respective resource pointer instead of dynamic casting, then I would not able to call those member functions on that object. 

Question – 3 In this workshop you had to use std::vector<sdds::Resource*> to store a collection of filesystem resources as pointers. Could you have used std::vector<sdds::Resource> instead?
Answer – In my opinion, we might not be able to use std::vector<sdds::Resource> instead of std::vector<sdds::Resource*>. The reason for this can be related to polymorphic objects  and dynamic_cast operation. In our design Resource is an Abstract Base Class and we are creating a vector of resource pointers in our Directory class. Those resource pointers can be directory and file and their types would be known at run time. Based on their types, the operations or member functions can be called on those objects. Getting the type of the resource at run time and performing operations based on that is related to inclusion polymorphism. If the resource itself is not a pointer and is an object of any type of Resource as asked in the question, then determining the type of those objects at run time might not be possible. Another reason is the dynamic cast operation. Dynamic cast operations only work with the pointer types and if we change the sdds::Resource* to sdds::Resource, then it might not be able to convert the types. However, in our application we need to convert the sdds::Resource to derived objects that is Directory and File so that the member functions can be executed on those objects. Hence, in my opinion we might not be able to use sdds::Resource for the given purpose.
